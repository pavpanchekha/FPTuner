max_order = 26;
difference_accuracy = 2^(-100);
I = [0; pi/4];
prec=2048!;

print("#include \"tan.h\"");
print("");
print("");
print("// Generated for input range:", I);
print("");
print("");

fptaylor_args = "--fp-power2-model true "@
                  "--opt gelpia "@
                  "--opt-f-rel-tol 1e-30 "@
                  "--opt-f-abs-tol 1e-30 "@
                  "--opt-x-rel-tol 1e-30 "@
                  "--opt-x-abs-tol 1e-30 "@
                  "--opt-max-iters 100000000 "@
                  "--opt-timeout 6000 ";


f = tan(x);
monomials = [||];
order = 0;
for power from 1 to (2*max_order) by 2 do begin
    order = order + 1;
    monomials = monomials:.power;
    extra = "0";
    if order > 9 then {
       extra = "";
    };

    p = fpminimax(f, monomials, [|single...|], I, floating, relative);
    filename = "tan.fpt";
    display = decimal!;
    midpointmode = off!;
    mul_horner = bashevaluate("echo '"@horner(p)@"' | sed 's|x^2|(x*x)|g'");
    comma_I = bashevaluate("echo '"@I@"' | sed 's|;|,|g'");
    print("Variables") > filename;
    print("real x in", comma_I, ";") >> filename;
    print("Definitions") >> filename;
    print("ret rnd32 =", mul_horner, ";") >> filename;
    print("Expressions") >> filename;
    print("ret;") >> filename;
    abs_err = bashevaluate("fptaylor --abs-error true "@fptaylor_args@filename@" 2>&1 | grep 'Absolute error (exact): .*' | sed 's|Absolute error (exact): ||g'");
    rel_err = bashevaluate("fptaylor --abs-error false --rel-error true "@fptaylor_args@filename@" 2>&1 | grep 'Relative error (exact): .*' | sed 's|Relative error (exact): ||g'");
    abs_algo_err = supnorm(p, f, I, absolute, difference_accuracy);
    rel_algo_err = supnorm(p, f, I, relative, difference_accuracy);

    if abs_err == "" then { abs_err = "error"; };
    if rel_err == "" then { rel_err = "error"; };

    if abs_err == "error" || abs_algo_err == "error" then {
       total_abs_err = "error";
    } else {
      total_abs_err = abs_algo_err + parse(abs_err);
    };

    if rel_err == "error" || rel_algo_err == "error" then {
       total_rel_err = "error";
    } else {
      total_rel_err = rel_algo_err + parse(rel_err);
    };

    display = hexadecimal!;
    flt_horner = bashevaluate("echo '"@horner(p)@"' | sed 's|x^0x1p1|(x*x)|g' | sed 's|\\([0-9]\\) |\\1f |g' | sed 's|\\([0-9]\\))|\\1f)|g' | sed 's|\\([0-9]\\)$|\\1f|g'");
    display = decimal!;

    midpointmode=on!;
    print("fp32 ord_"@extra@order@"_tan_fp32(fp32 x)");
    print("{");
    print("  // Absolute algorithmic error:", abs_algo_err);
    print("  // Relative algorithmic error:", rel_algo_err);
    print("  // Absolute rounding error:", abs_err);
    print("  // Relative rounding error:", rel_err);
    print("  // Total absolute error:", total_abs_err);
    print("  // Total relative error:", total_rel_err);
    print("  return ", flt_horner, ";");
    print("}");
    print("");


    p = fpminimax(f, monomials, [|double...|], I, floating, relative);
    filename = "tan.fpt";
    display = decimal!;
    midpointmode = off!;
    mul_horner = bashevaluate("echo '"@horner(p)@"' | sed 's|x^2|(x*x)|g' | sed 's|0x1p1|(x*x)|g'");
    comma_I = bashevaluate("echo '"@I@"' | sed 's|;|,|g'");
    print("Variables") > filename;
    print("real x in", comma_I, ";") >> filename;
    print("Definitions") >> filename;
    print("ret rnd64 =", mul_horner, ";") >> filename;
    print("Expressions") >> filename;
    print("ret;") >> filename;
    abs_err = bashevaluate("fptaylor --abs-error true "@fptaylor_args@filename@" 2>&1 | grep 'Absolute error (exact): .*' | sed 's|Absolute error (exact): ||g'");
    rel_err = bashevaluate("fptaylor --abs-error false --rel-error true "@fptaylor_args@filename@" 2>&1 | grep 'Relative error (exact): .*' | sed 's|Relative error (exact): ||g'");
    abs_algo_err = supnorm(p, f, I, absolute, difference_accuracy);
    rel_algo_err = supnorm(p, f, I, relative, difference_accuracy);

    if abs_err == "" then { abs_err = "error"; };
    if rel_err == "" then { rel_err = "error"; };

    if abs_err == "error" || abs_algo_err == "error" then {
       total_abs_err = "error";
    } else {
      total_abs_err = abs_algo_err + parse(abs_err);
    };

    if rel_err == "error" || rel_algo_err == "error" then {
       total_rel_err = "error";
    } else {
      total_rel_err = rel_algo_err + parse(rel_err);
    };

    display = hexadecimal!;
    flt_horner = bashevaluate("echo '"@horner(p)@"' | sed 's|x^0x1p1|(x*x)|g'");
    display = decimal!;

    midpointmode=on!;
    print("fp64 ord_"@extra@order@"_tan_fp64(fp64 x)");
    print("{");
    print("  // Absolute algorithmic error:", abs_algo_err);
    print("  // Relative algorithmic error:", rel_algo_err);
    print("  // Absolute rounding error:", abs_err);
    print("  // Relative rounding error:", rel_err);
    print("  // Total absolute error:", total_abs_err);
    print("  // Total relative error:", total_rel_err);
    print("  return ", flt_horner, ";");
    print("}");
    print("");

    print("");

end;
