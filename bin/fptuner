#!/usr/bin/env python3

import os.path as path
import sys

PYTHON_DIR = path.abspath(path.dirname(__file__))
GIT_DIR = path.split(PYTHON_DIR)[0]
sys.path.append(path.join(GIT_DIR, "src"))
sys.path.append(path.join(GIT_DIR, "src", "fptaylor"))
sys.path.append(path.join(GIT_DIR, "src", "fpcore_parser", "src"))

import check_requirements

from datetime import date
from fpcore_logging import Logger
from exceptions import DomainError, UnsupportedError, NoPreError, BadPreError
from fpcore_lexer import FPCoreLexer
from fpcore_parser import FPCoreParser
from z3_result import Z3Result
from tuned_expression import TunedExpression
from fptaylor_result import FPTaylorResult

import ast_modifications.all_modifications_ast as all_modifications_ast
import fptuner_argument_parser


logger = Logger(level=Logger.HIGH, color=Logger.green)


def main(argv):
    args = fptuner_argument_parser.parse_args(argv)

    # Grab all functions from the modifications table
    sins = [row[1] for row in all_modifications_ast.OperationTable
            if row[0] == "sin"]
    exps = [row[1] for row in all_modifications_ast.OperationTable
            if row[0] == "exp"]
    logs = [row[1] for row in all_modifications_ast.OperationTable
            if row[0] == "log"]
    operations = {"sin": sins,
                  "exp": exps,
                  "log": logs}

    # Setup the search space
    search_space = {"bit_widths": args.bit_widths,
                    "operations": operations}

    lexer = FPCoreLexer()
    parser = FPCoreParser()

    # Optionally print html header
    if args.nightly:
        today = date.today()
        (Y, m, d) = today.year, today.month, today.day
        print("<!doctype html>")
        print("<title>FPTuner Results for {}-{}-{}</title>".format(Y, m, d))
        print("<body>")

    for query_file in args.query_files:
        try:
            with open(query_file, "r") as f:
                text = f.read()

        except FileNotFoundError:
            logger.error("Unable to find file '{}'", query_file)
            continue

        # todo: add try catch for lex and parse errors
        tokens = lexer.tokenize(text)
        fpcores = parser.parse(tokens)

        if len(fpcores) == 0:
            logger.error("No FPCore found in file '{}'", query_file)
            continue

        for fpcore in fpcores:
            try:
                ssa = fpcore.to_single_assignment(search_space)
                ssa.get_fptaylor_forms()
                ssa.get_fptaylor_maximums()
                first_header = None
                rows = []
                for e in args.error:
                    zr = Z3Result(ssa, e)
                    tr = TunedExpression(ssa, zr)
                    header, row = tr.tsv()

                    if first_header is None:
                        first_header = header
                    elif first_header != header:
                        logger.error("Header mismatch: \n{} \n{}",
                                     first_header, header)
                        sys.exit(1)

                    if args.check:
                        query = tr.to_fptaylor()
                        res = FPTaylorResult(query, FPTaylorResult.CHECK_CONFIG)
                        if res.abs_error is None:
                            logger.error("FPTaylor did not find an error value")
                            res.abs_error = float("nan")
                            row.append("N/A")
                        else:
                            logger("FPTaylor error bound: {}", res.abs_error)
                            row.append(str(res.abs_error <= e))
                        row.append(str(res.high_second_order))
                    rows.append(row)

                if args.check:
                    first_header.append("FPTaylorCheck")
                    first_header.append("HighSecondOrder")

                if args.nightly:
                    print("<h1>{}</h1>".format(ssa.name))
                    print("<table>")
                    print("<tr><th>" + "</th><th>".join(first_header) + "</th></tr>")
                    for row in rows:
                        print("<tr><td>" + "</td><td>".join(row) + "</td></tr>")
                    print("</table>")
                else:
                    print(ssa.name)
                    print("\t".join(first_header))
                    for row in rows:
                        print("\t".join(row))

            except DomainError as e:
                if e.lower is None and e.upper is None:
                    logger.error("No domain defined for '{}'", e.name)
                elif e.lower is None:
                    logger.error("No lower bound defined for '{}'", e.name)
                else:
                    logger.error("No upper bound defined for '{}'", e.name)

            except UnsupportedError as e:
                msg = "Found unsupported FPCore language statement type '{}'"
                logger.error(msg, e.statement_type)

            except NoPreError:
                logger.error("No :pre property defined")

            except BadPreError as e:
                logger.error("Unable to process precondition: '{}'", e.pre)

    if args.nightly:
        print("</body>")


if __name__ == "__main__":
    try:
        retval = main(sys.argv)
    except KeyboardInterrupt:
        sys.exit(1)
    sys.exit(retval)
